<?php

/**
 * @file
 *   Send site profile information (NSPI) and system data to Acquia Network.
 */

define('ACQUIA_SPI_DATA_VERSION', '2.0');

/**
 * Implementation of hook_help()
 */
function acquia_spi_help($path, $arg) {
  $welcome_nid = variable_get('acquia_welcome', 0);
  if ($path == 'admin/help#acquia_nspi' && $welcome_nid) {
    // Only provide help text if the welcome message is avalailable.
    if ($nid = db_query('SELECT nid FROM {node} where nid = :nid', array(':nid' => $welcome_nid))->fetchField()) {
      $txt = 'The !acquia_welcome provides information about how to '
      . 'quickly get your site up and running.  Also there are instructions for '
      . 'setting the site theme as well as many other configuration tasks.';
      $link = l('Acquia Drupal welcome page', 'node/' . $nid);
      return '<p>' . t($txt, array('!acquia_welcome' => $link)) . '<p>';
    }
  }
}

/**
 * Implementation of hook_cron().
 */
function acquia_spi_cron() {
  // Get the last time we processed data.
  $last = variable_get('acquia_spi_cron_last', 0);

  // 30 minute interval for sending site profile.
  $interval = variable_get('acquia_spi_cron_interval', 30);

  // Allow an override. 
  if (variable_get('acquia_spi_cron_interval_override', FALSE)) {
    $interval = variable_get('acquia_spi_cron_interval_override', 30);
  }

  // Determine if the required interval has passed.
  $now = REQUEST_TIME;
  if (variable_get('acquia_spi_use_cron', 1) && $now - $last > ($interval * 60)) {
    $ret = acquia_spi_send_profile_info();
  }
}

/**
 * Implements hook_menu().
 */
function acquia_spi_menu() {
  $items['system/acquia-spi-send'] = array(
    'title' => 'Acquia SPI Send',
    'description' => 'Send SPI data to Acquia Network.',
    'page callback' => '_acquia_spi_send',
    'access callback' => '_acquia_spi_send_access',
  );

  return $items;
}

/**
 * Implements hook_boot().
 */
function acquia_spi_boot() {
  // Store server information for SPI incase data is being sent from PHP CLI.
  if (drupal_is_cli()) {
    return;
  }

  // Get the last time we processed data.
  $last = variable_get('acquia_spi_boot_last', 0);
  // 60 minute interval for storing the global variable.
  $interval = variable_get('acquia_spi_cron_interval', 60);
  // Determine if the required interval has passed.
  $now = REQUEST_TIME;
  if ((($now - $last) > ($interval * 60))) {
    cache_set('acquia_spi_server', $_SERVER);
    variable_set('acquia_spi_boot_last', $now);
  }
}

/**
 * Access callback check for SPI send independent call.
 */
function _acquia_spi_send_access() {
  $acquia_key = acquia_agent_settings('acquia_key');
  if (!empty($acquia_key) && isset($_GET['key'])) {
    $key = sha1(drupal_get_private_key());
    if ($key == $_GET['key']) {
      return TRUE;
    }
  }
  return FALSE;
}

/**
 * Callback for sending SPI data.
 */
function _acquia_spi_send() {
  $ret = acquia_spi_send_profile_info();

  if (isset($_GET['destination'])) {
    if ($ret) {
      drupal_set_message(t('SPI data sent.'));
    }
    else {
      drupal_set_message(t('There was an error sending SPI data. Check the logs for error messages or contact Acquia Support.'), 'error');
    }
    drupal_goto();
  }
  // If destination was not sent the call is via cron so close request and exit.
  module_invoke_all('exit');
  print '';
  exit;
}

/**
 * Implementation of hook_xmlrpc().
 */
function acquia_spi_xmlrpc() {
  return array(
    array(
      'acquia.nspi.send.module.data',
      'acquia_spi_send_module_data',
      array('string', 'array'),
      t('Send file data for the provided path.')),
    );
}

function acquia_spi_valid_request($data, $message) {
  $key = acquia_agent_settings('acquia_key');
  if (!isset($data['authenticator']) || !isset($data['authenticator']['time']) || !isset($data['authenticator']['nonce'])) {
    return FALSE;
  }
  $string = $data['authenticator']['time'] . ':' . $data['authenticator']['nonce'] . ':' . $message;
  $hash = sha1((str_pad($key, 64, chr(0x00)) ^ (str_repeat(chr(0x5c), 64))) . pack("H*", sha1((str_pad($key, 64, chr(0x00)) ^ (str_repeat(chr(0x36), 64))) . $string)));
  if ($hash == $data['authenticator']['hash']) {
    return TRUE;
  }
  else {
    return FALSE;
  }
}

/**
 * Send a file's contents to the requestor
 */
function acquia_spi_send_module_data($data = array()) {
  // We only do this if we are on SSL
  $via_ssl = isset($_SERVER['HTTPS']) ? TRUE : FALSE;
  if (variable_get('acquia_spi_module_diff_data', 1) && $via_ssl
      && acquia_agent_has_credentials() && isset($data['body']['file'])
      && acquia_spi_valid_request($data, $data['body']['file'])) {
    // If our checks pass muster, then we'll provide this data.
    // If the file variable is set and if the user has allowed file diffing.
    $file = $data['body']['file'];
    $document_root = getcwd();
    $file_path = realpath($document_root . '/' . $file);
    // Be sure the file being requested is within the webroot and is not any
    // settings.php file.
    if (is_file($file_path) && strpos($file_path, $document_root) === 0 && strpos($file_path, 'settings.php') === FALSE) {
      $file_contents = file_get_contents($file_path);
      header("Expires: Mon, 26 Jul 1997 05:00:00 GMT");
      header("Content-Type:text");  
      header("Cache-Control: no-cache");
      header("Pragma: no-cache");
      return $file_contents;
    }
  }

  return FALSE;
}

/**
 * Implementation of hook_form_[form_id]_alter().
 */
function acquia_spi_form_acquia_agent_settings_form_alter(&$form) {
  $identifier = acquia_agent_settings('acquia_identifier');
  $key = acquia_agent_settings('acquia_key');
  if (empty($identifier) && empty($key)) {
    return;
  }

  $ssl_available = (in_array('ssl', stream_get_transports(), TRUE) && !defined('ACQUIA_DEVELOPMENT_NOSSL'));
  $form['connection']['#description'] = t('Allow collection and examination of the following items. <a href="!url">Learn more</a>.', array('!url' => url('admin/help/acquia_agent')));
  
  $form['connection']['spi'] = array(
    '#prefix' => '<div class="acquia-spi">',
    '#suffix' => '</div>',
    '#weight' => -1,
  );
  $form['connection']['spi']['admin_priv'] = array(
    '#type' => 'checkbox',
    '#title' => t('Admin privileges'),
    '#default_value' => variable_get('acquia_spi_admin_priv', 1),
  );
  $form['connection']['spi']['send_node_user'] = array(
    '#type' => 'checkbox',
    '#title' => t('Nodes and users'),
    '#default_value' => variable_get('acquia_spi_send_node_user', 1),
  );
  $form['connection']['spi']['send_watchdog'] = array(
    '#type' => 'checkbox',
    '#title' => t('Watchdog logs'),
    '#default_value' => variable_get('acquia_spi_send_watchdog', 1),
  );
  $form['connection']['spi']['module_diff_data'] = array(
    '#type' => 'checkbox',
    '#title' => t('Source code'),
    '#default_value' => (int) variable_get('acquia_spi_module_diff_data', 1) && $ssl_available,
    '#description' => t('Source code analysis requires a SSL connection and for your site to be publicly accessible. <a href="!url">Learn more.</a>', array('!url' => url('admin/help/acquia_agent'))),
    '#disabled' => !$ssl_available,
  );

  $use_cron = variable_get('acquia_spi_use_cron', 1);
  $form['connection']['spi_use_cron'] = array(
    '#type' => 'checkbox',
    '#title' => t('Send via Drupal cron'),
    '#default_value' => $use_cron,
  );
  $key = sha1(drupal_get_private_key());
  $url = url('system/acquia-spi-send', array('query' => array('key' => $key), 'absolute' => TRUE));
  $form['connection']['spi_use_cron_url'] = array(
    '#type' => 'container',
    '#children'  => t('<p>Enter the following URL in your server\'s crontab to send SPI data:<br/><em>!url</em></p>', array('!url' => $url)),
    '#states' => array(
      'visible' => array(
        ':input[name="spi_use_cron"]' => array('checked' => FALSE),
      )
    ),
  );
  if ($use_cron) {
    // If using cron hide the URL container with #states visible.
    $form['connection']['spi_use_cron_url']['#states'] = array(
      'visible' => array(
        ':input[name="spi_use_cron"]' => array('checked' => FALSE),
      )
    );
  }

  $form['actions']['submit']['#submit'][] = 'acquia_agent_spi_set_submit';
}

/**
 * Added submit function for acquia_agent_settings form.
 */
function acquia_spi_agent_settings_submit($form, &$form_state) {
  // Send information as soon as the key/identifier pair is submitted.
  acquia_spi_send_profile_info();
}

/*
 * Save the results of the NSPI form
 */
function acquia_agent_spi_set_submit($form, &$form_state) {
  variable_set('acquia_spi_module_diff_data', $form_state['values']['module_diff_data']);
  variable_set('acquia_spi_admin_priv', $form_state['values']['admin_priv']);
  variable_set('acquia_spi_send_node_user', $form_state['values']['send_node_user']);
  variable_set('acquia_spi_send_watchdog', $form_state['values']['send_watchdog']);
  variable_set('acquia_spi_use_cron', $form_state['values']['spi_use_cron']);
}

/**
 * Checks if NSPI server has an updated SPI data definition.
 * If it does, then this function updates local copy of SPI definition data.
 *
 * @return boolean
 *   True if SPI definition data has been updated
 */
function acquia_spi_update_definition() {
  $core_version = substr(VERSION, 0, 1);
  $spi_def_end_point = variable_get('acquia_spi_server', 'https://nspi.acquia.com');
  $spi_def_end_point .= '/spi_def/get/' . $core_version;
  $options = array(
    'method' => 'GET',
    'headers' => array('Content-type' => 'application/json'),
    'data' => drupal_http_build_query(array('spi_data_version' => ACQUIA_SPI_DATA_VERSION))
  );
  $response = drupal_http_request($spi_def_end_point, $options);
  if ($response->code != 200 || !isset($response->data)) {
    watchdog('acquia spi', 'Failed to obtain latest SPI data definition. HTTP response: @response', array('@response' => var_export($response, TRUE)), WATCHDOG_ERROR);
    return FALSE;
  }
  else {
    $response_data = drupal_json_decode($response->data);
    $expected_data_types = array(
      'drupal_version' => 'string',
      'timestamp' => 'string',
      'acquia_spi_variables' => 'array',
    );
    // Make sure that $response_data contains everything expected.
    foreach($expected_data_types as $key => $values) {
      if (!array_key_exists($key, $response_data) || gettype($response_data[$key]) != $expected_data_types[$key]) {
        watchdog('acquia spi', 'Received SPI data definition does not match expected pattern while checking "@key". Received and expected data: @data', array('@key' => $key, '@data' => var_export(array_merge(array('expected_data' => $expected_data_types), array('response_data' => $response_data)), 1), TRUE), WATCHDOG_ERROR);
        return FALSE;
      }
    }
    if ($response_data['drupal_version'] != $core_version) {
      watchdog('acquia spi', 'Received SPI data definition does not match with current version of your Drupal installation. Data received for Drupal @version', array('@version' => $response_data['drupal_version']), WATCHDOG_ERROR);
      return FALSE;
    }
  }

  // NSPI response is in expected format.
  if ((int) $response_data['timestamp'] > (int) variable_get('acquia_spi_def_timestamp', 0)) {
    // Compare stored variable names to incoming and report on update.
    $old_vars = variable_get('acquia_spi_def_vars', array());
    $new_vars = $response_data['acquia_spi_variables'];
    $new_optional_vars = 0;
    foreach($new_vars as $new_var_name => $new_var) {
      // Count if received from NSPI optional variable is not present in old local SPI definition
      // or if it already was in old SPI definition, but was not optional
      if ($new_var['optional'] && !array_key_exists($new_var_name, $old_vars) || 
          $new_var['optional'] && isset($old_vars[$new_var_name]) && !$old_vars[$new_var_name]['optional']) {
        $new_optional_vars++;
      }
    }
    // Clean up waived vars that are not exposed by NSPI anymore.
    $waived_spi_def_vars = variable_get('acquia_spi_def_waived_vars', array());
    $changed_bool = FALSE;
    foreach($waived_spi_def_vars as $key => $waived_var) {
      if (!in_array($waived_var, $new_vars)) {
        unset($waived_spi_def_vars[$key]);
        $changed_bool = TRUE;
      }
    }
    if ($changed_bool) {
      variable_set('acquia_spi_def_waived_vars', $waived_spi_def_vars);
    }
    // Finally, save SPI definition data.
    if ($new_optional_vars > 0) {
      variable_set('acquia_spi_new_optional_data', 1);
    }
    variable_set('acquia_spi_def_timestamp', $response_data['timestamp']);
    variable_set('acquia_spi_def_vars', $response_data['acquia_spi_variables']);
    return TRUE;
  }
  return FALSE;
}

/**
 * Send site profile information to Acquia Network via XML-RPC.
 */
function acquia_spi_send_profile_info() {
  // Do nothing unless we have credentials.
  if (acquia_agent_has_credentials()) {
    // acquia_agent_network_address() sets remote server protocol.
    $nspi_server = variable_get('acquia_spi_server', 'https://nspi.acquia.com');
    $spi = acquia_spi_get();
    // Specify version 3 of the RPC, which ommits request parameters in the HMAC.
    // @todo move to version 4, JSON over XML-RPC.
    $spi['rpc_version'] = 3;
    $result = acquia_agent_call('acquia.nspi.update', $spi, NULL, NULL, $nspi_server);
    // Check result for command to update SPI definition.
    $update_command = isset($result['result']['update_spi_definition']) ? $result['result']['update_spi_definition'] : FALSE;
    if ($update_command == TRUE) {
      acquia_spi_update_definition();
    }

    variable_set('acquia_spi_cron_last', REQUEST_TIME);
    return $result['result'];
  }
}

/**
 * Gather site profile information about this site.
 *
 * @return
 *   An associative array keyed by types of information.
 */
function acquia_spi_get() {

  // Get file hashes and compute serialized version.
  list($hashes, $fileinfo) = acquia_spi_file_hashes();
  $hashes_string = serialize($hashes);

  // Get the Drupal version
  $drupal_version = acquia_spi_get_version_info();

  // Default values return
  $spi = array(
    'spi_data_version' => ACQUIA_SPI_DATA_VERSION,
    'site_key'        => sha1(drupal_get_private_key()),
    'modules'        => acquia_spi_get_modules(),
    'platform'       => acquia_spi_get_platform(),
    'quantum'        => acquia_spi_get_quantum(),
    'system_status'  => acquia_spi_get_system_status(),
    'failed_logins'  => variable_get('acquia_spi_send_watchdog', 1) ? acquia_spi_get_failed_logins() : array(),
    '404s'           => variable_get('acquia_spi_send_watchdog', 1) ? acquai_spi_get_404s() : array(),
    'watchdog_size'  => acquai_spi_get_watchdog_size(),
    'watchdog_data'  => variable_get('acquia_spi_send_watchdog', 1) ? acquia_spi_get_watchdog_data() : array(),
    'last_nodes'     => variable_get('acquia_spi_send_node_user', 1) ? acquai_spi_get_last_nodes() : array(),
    'last_users'     => variable_get('acquia_spi_send_node_user', 1) ? acquai_spi_get_last_users() : array(),
    'extra_files'    => acquia_spi_check_files_present(),
    'ssl_login'      => acquia_spi_check_login(),
    'file_hashes'    => $hashes,
    'hashes_md5'     => md5($hashes_string),
    'hashes_sha1'    => sha1($hashes_string),
    'fileinfo'       => $fileinfo,
    'distribution'   => isset($drupal_version['distribution']) ? $drupal_version['distribution'] : '',
    'base_version'   => $drupal_version['base_version'],
    'build_data'     => $drupal_version,
    'roles'          => drupal_json_encode(user_roles()),
    'uid_0_present'  => acquia_spi_uid_0_present(),
  );

  $scheme = parse_url(variable_get('acquia_spi_server', 'https://nspi.acquia.com'), PHP_URL_SCHEME);
  $via_ssl = (in_array('ssl', stream_get_transports(), TRUE) && $scheme == 'https') ? TRUE : FALSE;
  if (variable_get('acquia_spi_ssl_override', FALSE)) {
    $via_ssl = TRUE;
  }

  $additional_data = array();
  $security_review_results = acquia_spi_run_security_review();
  if (!empty($security_review_results)) {
    $additional_data['security_review'] = $security_review_results['security_review'];
  }
  $spi_data = module_invoke_all('acquia_spi_get');
  if (!empty($spi_data)) {
    foreach ($spi_data as $name => $data) {
      if (is_string($name) && is_array($data)) {
        $additional_data[$name] = $data;
      }
    }
  }
  if (!empty($additional_data)) {
    // JSON encode this additional data.
    $spi['additional_data'] = drupal_json_encode($additional_data);
  }

  if (!$via_ssl) {
    return $spi;
  }
  else {

    // Values returned only over SSL
    $spi_ssl = array(
      'system_vars'  => acquia_spi_get_variables_data(),
      'settings_ra'  => acquia_spi_get_settings_permissions(),
      'admin_count'  => variable_get('acquia_spi_admin_priv', 1) ? acquia_spi_get_admin_count() : '',
      'admin_name'   => variable_get('acquia_spi_admin_priv', 1) ? acquia_spi_get_super_name() : '',
    );

    return array_merge($spi, $spi_ssl);
  }
}

/**
 * Run some checks from the Security Review module.
 */
function acquia_spi_run_security_review() {
  if (!_acquia_spi_security_review_compatible()) {
    // Older versions of Security Review are not compatible and the results
    // cannot easily be retrieved.
    return array();
  }
  module_load_include('inc', 'acquia_spi', 'security_review');

  $checklist_results = array();
  $skips = array();
  // Collect the checklist.
  $checklist = acquia_spi_security_review_get_checks();
  // Run only specific checks.
  $to_check = array('input_formats', 'admin_permissions', 'untrusted_php', 'private_files', 'upload_extensions');
  foreach ($checklist as $module => $checks) {
    foreach ($checks as $check_name => $args) {
      if (!in_array($check_name, $to_check)) {
        unset($checklist[$module][$check_name]);
      }
    }
    if (empty($checklist[$module])) {
      unset($checklist[$module]);
    }
  }
  $checklist_results = acquia_spi_security_review_run($checklist);
  foreach ($checklist_results as $module => $checks) {
    foreach ($checks as $check_name => $check) {
      // Unset data that does not need to be sent.
      if (is_null($check['result'])) {
        unset($checklist_results[$module][$check_name]);
      }
      else {
        unset($check['success']);
        unset($check['failure']);
        $checklist_results[$module][$check_name] = $check;
      }
    }
    if (empty($checklist_results[$module])) {
       unset($checklist_results[$module]);
    }
  }
  return $checklist_results;
}

/**
 * Helper function checks for conflict with full Security Review module.
 */
function _acquia_spi_security_review_compatible() {
  if (module_exists('security_review')) {
    if (file_exists(drupal_get_path('module', 'security_review') . DIRECTORY_SEPARATOR . 'security_review.inc')) {
      // Versions with the separate .inc file are compatible.
      return TRUE;
    }
    else {
      return FALSE;
    }
  }
  return TRUE;
}

/**
 * Attempt to determine the version of Drupal being used. 
 * Note, there is better information on this in the common.inc file.
 * 
 * @return array
 *    An array containing some detail about the version
 */
function acquia_spi_get_version_info() {
  $server = acquia_spi_get_server();
  $ver = array();

  $ver['base_version'] = VERSION;
  $install_root = $server['DOCUMENT_ROOT'] . base_path();
  $ver['distribution']  = '';

  // Determine if this puppy is Acquia Drupal
  acquia_agent_load_versions();
  if (IS_ACQUIA_DRUPAL) {
    $ver['distribution']   = 'Acquia Drupal';
    $ver['ad']['version']  = ACQUIA_DRUPAL_VERSION;
    $ver['ad']['series']   = ACQUIA_DRUPAL_SERIES;
    $ver['ad']['branch']   = ACQUIA_DRUPAL_BRANCH;
    $ver['ad']['revision'] = ACQUIA_DRUPAL_REVISION;
  }

  // Determine if we are looking at Pressflow
  if (defined('CACHE_EXTERNAL')) {
    $ver['distribution']  = 'Pressflow';
    $press_version_file = $install_root . './PRESSFLOW.txt';
    if (is_file($press_version_file)) {
      $ver['pr']['version'] = trim(file_get_contents($press_version_file));
    }
  }
  // Determine if this is Open Atrium
  elseif (is_dir($install_root . '/profiles/openatrium')) {
    $ver['distribution']  = 'Open Atrium';
    $version_file = $install_root . 'profiles/openatrium/VERSION.txt';
    if (is_file($version_file)) {
      $ver['oa']['version'] = trim(file_get_contents($version_file));
    }
  }
  // Determine if this is Commons
  elseif (is_dir($install_root . '/profiles/commons')) {
    $ver['distribution']  = 'Commons';
  }
  // Determine if this is COD.
  elseif (is_dir($install_root . '/profiles/cod')) {
    $ver['distribution']  = 'COD';
  }

  return $ver;
}

/**
 * Checks to see if SSL login is required
 *
 * @param n/a
 *
 * @return boolean
 */
function acquia_spi_check_login() {
  $login_safe = 0;
  if (module_exists('securepages')) {

    if (drupal_match_path('user/login', variable_get('securepages_pages', ''))) { 
      $login_safe = 1; 
    }
    if (drupal_match_path('user/login', variable_get('securepages_ignore', ''))) { 
      $login_safe = 0; 
    }
    if (!variable_get('securepages_secure', FALSE) || !variable_get('securepages_enable', FALSE)) { 
      $login_safe = 0; 
    }
    
  }

  return $login_safe;
}

/**
 * Determines if settings.php is read-only
 *
 * @param n/a
 *
 * @return boolean
 *   
 */
function acquia_spi_get_settings_permissions() {
  $settings_permissions_read_only = TRUE;
  $writes = array('2', '3', '6', '7'); // http://en.wikipedia.org/wiki/File_system_permissions
  $settings_file = './' . conf_path(FALSE, TRUE) . '/settings.php';
  $permissions = drupal_substr(sprintf('%o', fileperms($settings_file)), -4);  

  foreach ($writes as $bit) {
    if (strpos($permissions, $bit)) {
      $settings_permissions_read_only = FALSE;
      break;
    }
  }

  return $settings_permissions_read_only;
}

/**
 * Check to see if the unneeded release files with Drupal are removed
 *
 * @param n/a
 *
 * @return
 *   True if they are removed, false if they aren't
 */
function acquia_spi_check_files_present() {
  $server = acquia_spi_get_server();
  $files_exist = FALSE;
  $url = url(NULL, array('absolute' => TRUE));
  $files_to_remove = array('CHANGELOG.txt', 'COPYRIGHT.txt', 'INSTALL.mysql.txt', 'INSTALL.pgsql.txt', 'INSTALL.txt', 'LICENSE.txt',
    'MAINTAINERS.txt', 'README.txt', 'UPGRADE.txt', 'PRESSFLOW.txt', 'install.php');

  foreach ($files_to_remove as $file) {
    $path = $server['DOCUMENT_ROOT'] . base_path() . $file;
    if (file_exists($path))
      $files_exist = TRUE;
  }

  return $files_exist ? 1 : 0;
}

/**
 * Get lsat 15 users created--useful for determining if your site is comprimised
 *
 * @param n/a
 *
 * @return array of the details of last 15 users created
 */
function acquai_spi_get_last_users() {
  $last_five_users = array();
  $result = db_select('users', 'u')
    ->fields('u', array('uid', 'name', 'mail', 'created'))
    ->condition('u.created', REQUEST_TIME - 3600, '>')
    ->orderBy('created', 'DESC')
    ->range(0, 15)
    ->execute();

  $count = 0;
  foreach ($result as $record) {
    $last_five_users[$count]['uid'] = $record->uid;
    $last_five_users[$count]['name'] = $record->name;
    $last_five_users[$count]['email'] = $record->mail;
    $last_five_users[$count]['created'] = $record->created;
    $count++;
  }
//TODO is this what we really want?
  return $last_five_users;
}

/**
 * Get last 15 nodes created--this can be useful to determine if you have some
 * sort of spamme on your site
 *
 * @param n/a
 *
 * @return array of the details of last 15 nodes created
 */
function acquai_spi_get_last_nodes() {
  $last_five_nodes = array();
  $result = db_select('node', 'n')
    ->fields('n', array('title', 'type', 'nid', 'created'))
    ->condition('n.created', REQUEST_TIME - 3600, '>')
    ->orderBy('n.created', 'DESC')
    ->range(0, 15)
    ->execute();

  $count = 0;
  foreach ($result as $record) {
    $last_five_nodes[$count]['url'] = drupal_get_path_alias('node/' . $record->nid);
    $last_five_nodes[$count]['title'] = $record->title;
    $last_five_nodes[$count]['type'] = $record->type;
    $last_five_nodes[$count]['created'] = $record->created;
    $count++;
  }

  return $last_five_nodes;

}

/**
 * Get the number of rows in watchdog
 *
 * @param n/a
 *
 * @return int
 *
 */
function acquai_spi_get_watchdog_size() {
  if (module_exists('dblog')) {
    return db_select('watchdog', 'w')->fields('w', array('wid'))->countQuery()->execute()->fetchField();
  }
}

/**
 * Get the latest (last hour) critical and emergency warnings from watchdog
 * These errors are 'severity' 0 and 2.
 *
 * @param n/a
 *
 * @return array
 *
 */
function acquia_spi_get_watchdog_data() {
  $wd = array();
  if (module_exists('dblog')) {
    $result = db_select('watchdog', 'w')
      ->fields('w', array('wid', 'severity', 'type', 'message', 'timestamp'))
      ->condition('w.severity', array(WATCHDOG_EMERGENCY, WATCHDOG_CRITICAL), 'IN')
      ->condition('w.timestamp', REQUEST_TIME - 3600, '>')
      ->execute();

    while ($record = $result->fetchAssoc()) {
      $wd[$record['severity']] = $record;
    }
  }
  return $wd;
}

/**
 * Grabs the last 404 errors in logs, excluding the checks we run for drupal files like README
 *
 * @param n/a
 *
 * @return
 *   An array of the pages not found and some associated data
 */
function acquai_spi_get_404s() {
  $data = array();
  $row = 0;

  if (module_exists('dblog')) {
    $result = db_select('watchdog', 'w')
      ->fields('w', array('message', 'hostname', 'referer', 'timestamp'))
      ->condition('w.type', 'page not found', '=')
      ->condition('w.timestamp', REQUEST_TIME - 3600, '>')
      ->condition('w.message', array("UPGRADE.txt", "MAINTAINERS.txt", "README.txt", "INSTALL.pgsql.txt", "INSTALL.txt", "LICENSE.txt", "INSTALL.mysql.txt", "COPYRIGHT.txt", "CHANGELOG.txt"), 'NOT IN')
      ->orderBy('w.timestamp', 'DESC')
      ->range(0, 10)
      ->execute();

    foreach ($result as $record) {
      $data[$row]['message'] = $record->message;
      $data[$row]['hostname'] = $record->hostname;
      $data[$row]['referer'] = $record->referer;
      $data[$row]['timestamp'] = $record->timestamp;
      $row++;
    }
  }

  return $data;
}

/**
 * Get all system variables
 *
 * @return JSON string
 */
function acquia_spi_get_variables_data() {
  global $conf;
  $data = array();
  $variables = array('acquia_spi_send_node_user', 'acquia_spi_admin_priv', 'acquia_spi_module_diff_data', 'acquia_spi_send_watchdog', 'acquia_spi_use_cron', 'cache_backends', 'cache_default_class', 'cache_inc', 'cron_safe_threshold', 'googleanalytics_cache', 'error_level', 'preprocess_js', 'page_cache_maximum_age', 'block_cache', 'preprocess_css', 'page_compression', 'cache', 'cache_lifetime', 'cron_last', 'clean_url', 'redirect_global_clean', 'theme_zen_settings', 'site_offline', 'site_name', 'user_register', 'user_signatures', 'user_admin_role', 'user_email_verification', 'user_cancel_method', 'filter_fallback_format', 'dblog_row_limit', 'date_default_timezone', 'file_default_scheme', 'install_profile', 'maintenance_mode', 'update_last_check', 'site_default_country');
  $spi_def_vars = variable_get('acquia_spi_def_vars', array());
  $waived_spi_def_vars = variable_get('acquia_spi_def_waived_vars', array());
  // Merge hard coded $variables with vars from SPI definition.
  foreach($spi_def_vars as $var_name => $var) {
    if (!in_array($var_name, $waived_spi_def_vars) && !in_array($var_name, $variables)) {
      $variables[] = $var_name;
    }
  }
  // Add comment settings for node types.
  $types = node_type_get_types();
  if (!empty($types)) {
    foreach ($types as $name => $type) {
      $variables[] = 'comment_' . $name;
    }
  }
  foreach ($variables as $name) {
    if (isset($conf[$name])) {
      $data[$name] = $conf[$name];
    }
  }
  // Exception handling.
  if (module_exists('globalredirect') && function_exists('_globalredirect_get_settings')) {
    // Explicitly get Global Redirect settings since it deletes its variable
    // if the settings match the defaults.
    $data['globalredirect_settings'] = _globalredirect_get_settings();
  }
  // Drush overrides cron_safe_threshold so extract DB value if sending via drush.
  if (drupal_is_cli()) {
    $cron_safe_threshold = acquia_spi_get_db_variable('cron_safe_threshold');
    $data['cron_safe_threshold'] = !is_null($cron_safe_threshold) ? $cron_safe_threshold : DRUPAL_CRON_DEFAULT_THRESHOLD;
  }
  // Unset waived vars so they won't be sent to NSPI.
  foreach($data as $var_name => $var) {
    if (in_array($var_name, $waived_spi_def_vars)) {
      unset($data[$var_name]);
    }
  }
  // Collapse to JSON string to simplify transport.
  return drupal_json_encode($data);
}

/**
 * Get a variable from the DB explicitely skipping global $conf array.
 */
function acquia_spi_get_db_variable($name) {
  $result = db_query("SELECT value FROM {variable} WHERE name = :name", array(':name' => $name));
  if ($result->rowCount() == 1) {
    return unserialize($result->fetchField());
  }
  return NULL;
}

/**
 * Get the information on failed logins in the last cron interval
 *
 * @param n/a
 *
 * @return array
 *
 */
function acquia_spi_get_failed_logins() {
  $last_logins = array();
  $cron_interval = variable_get('acquia_spi_cron_interval', 8*60*60);

  if (module_exists('dblog')) {
    $result = db_select('watchdog', 'w')
      ->fields('w', array('message', 'variables'))
      ->condition('w.message', 'login attempty failed%', 'LIKE')
      ->condition('w.timestamp', REQUEST_TIME - $cron_interval, '>')
      ->condition('w.message', array("UPGRADE.txt", "MAINTAINERS.txt", "README.txt", "INSTALL.pgsql.txt", "INSTALL.txt", "LICENSE.txt", "INSTALL.mysql.txt", "COPYRIGHT.txt", "CHANGELOG.txt"), 'NOT IN')
      ->orderBy('w.timestamp', 'DESC')
      ->range(0, 10)
      ->execute();
  
    foreach ($result as $record) {
      $variables = unserialize($record->variables);
      $last_logins['failed'][$record->timestamp] = check_plain($variables['%user']);
    }
  }
  return $last_logins;
}

/**
 * Determine if the super user has a weak name
 * 
 * @return boolean
 */
function acquia_spi_get_super_name() {
  $result = db_query("SELECT name FROM {users} WHERE uid = 1 AND (name LIKE '%admin%' OR name LIKE '%root%')")->fetch();
  if ($result) {
    return TRUE;
  }
  else {
    return FALSE;
  }
}

/**
 * The number of users who have admin-level user roles.
 *
 * @param n/a
 *
 * @return int
 *
 */
function acquia_spi_get_admin_count() {
  $count = NULL;
  $sql = "SELECT COUNT(DISTINCT u.uid) as count
              FROM {users} u, {users_roles} ur, {role_permission} p
              WHERE u.uid = ur.uid
                AND ur.rid = p.rid
                AND u.status = 1
                AND (p.permission LIKE '%administer permissions%' OR p.permission LIKE '%administer users%')";
  $result = db_query($sql)->fetchObject();

  return (isset($result->count) && is_numeric($result->count)) ? $result->count : NULL;
}

/**
 * Gather platform specific information.
 *
 * @return
 *   An associative array keyed by a platform information type.
 */
function acquia_spi_get_platform() {
  $server = acquia_spi_get_server();
  // Database detection depends on the structure starting with the database
  $db_class = 'DatabaseTasks_' . Database::getConnection()->driver();
  $db_tasks = new $db_class();
  // Webserver detection is based on name being before the slash, and
  // version being after the slash.
  preg_match('!^([^/]+)(/.+)?$!', $server['SERVER_SOFTWARE'], $webserver);

  if (stristr($webserver[1], 'Apache') && function_exists('apache_get_version')) {
    $webserver[2] = apache_get_version();
    $apache_modules = apache_get_modules();
  }
  else {
    $apache_modules = '';
  }

  // Get some basic PHP vars
  $php_quantum = array(
    'memory_limit'            => ini_get('memory_limit'),
    'register_globals'        => ini_get('register_globals'),
    'post_max_size'           => ini_get('post_max_size'),
    'max_execution_time'      => ini_get('max_execution_time'),
    'upload_max_filesize'     => ini_get('upload_max_filesize'),
    'error_log'               => ini_get('error_log'),
    'error_reporting'         => ini_get('error_reporting'),
    'display_errors'          => ini_get('display_errors'),
    'log_errors'              => ini_get('log_errors'),
    'session.cookie_domain'   => ini_get('session.cookie_domain'),
    'session.cookie_lifetime' => ini_get('session.cookie_lifetime'),
    'newrelic.appname'        => ini_get('newrelic.appname'),
    'SERVER'                  => $server,
    'sapi'                    => php_sapi_name(),
  );

  $platform = array(
    'php'               => PHP_VERSION,
    'webserver_type'    => isset($webserver[1]) ? $webserver[1] : '',
    'webserver_version' => isset($webserver[2]) ? $webserver[2] : '',
    'apache_modules'    => $apache_modules,
    'php_extensions'    => get_loaded_extensions(),
    'php_quantum'       => $php_quantum,
    'database_type'     => $db_tasks->name(),
    'database_version'  => Database::getConnection()->version(),
    'system_type'       => php_uname('s'),
    // php_uname() only accepts one character, so we need to concatenate ourselves.
    'system_version'    => php_uname('r') . ' ' . php_uname('v') . ' ' . php_uname('m') . ' ' . php_uname('n'),
    'mysql'             => (Database::getConnection()->driver() == 'mysql') ? acquia_spi_get_platform_mysql_data() : array(),
    'server'            => '',
    'apache'            => '',
  );

  // Never send NULL (or FALSE?) - that causes hmac errors.
  foreach ($platform as $key => $value) {
    if (empty($platform[$key])) {
      $platform[$key] = '';
    }
  }
  return $platform;
}

function acquia_spi_get_platform_mysql_data() {
  $connection = Database::getConnection('default');
  // Backup and restore PDO::ATTR_CASE. Prior to Drupal 7.14 this is
  // PDO::CASE_LOWER. Afterwards it is PDO::CASE_NATURAL.
  $orig = $connection->getAttribute(PDO::ATTR_CASE);
  $connection->setAttribute(PDO::ATTR_CASE, PDO::CASE_LOWER);
  $result = $connection->query("SHOW GLOBAL STATUS", array(), array());
  // Restore the attribute.
  $connection->setAttribute(PDO::ATTR_CASE, $orig);

  // what happens if we run this on mssql or postgres
  $ret = array();
  if (empty($result)) {
    return $ret;
  }
  foreach ($result as $record) {
    if (!isset($record->variable_name)) {
      continue;
    }
    switch ($record->variable_name) {
      case 'Table_locks_waited':
        $ret['Table_locks_waited'] = $record->value;
        break;
      case 'Slow_queries':
        $ret['Slow_queries'] = $record->value;
        break;
      case 'Qcache_hits':
        $ret['Qcache_hits'] = $record->value;
        break;
      case 'Qcache_inserts':
        $ret['Qcache_inserts'] = $record->value;
        break;
      case 'Qcache_queries_in_cache':
        $ret['Qcache_queries_in_cache'] = $record->value;
        break;
      case 'Qcache_lowmem_prunes':
        $ret['Qcache_lowmem_prunes'] = $record->value;
        break;
      case 'Open_tables':
        $ret['Open_tables'] = $record->value;
        break;
      case 'Opened_tables':
        $ret['Opened_tables'] = $record->value;
        break;
      case 'Select_scan':
        $ret['Select_scan'] = $record->value;
        break;
      case 'Select_full_join':
        $ret['Select_full_join'] = $record->value;
        break;
      case 'Select_range_check':
        $ret['Select_range_check'] = $record->value;
        break;
      case 'Created_tmp_disk_tables':
        $ret['Created_tmp_disk_tables'] = $record->value;
        break;
      case 'Created_tmp_tables':
        $ret['Created_tmp_tables'] = $record->value;
        break;
      case 'Handler_read_rnd_next':
        $ret['Handler_read_rnd_next'] = $record->value;
        break;
      case 'Sort_merge_passes':
        $ret['Sort_merge_passes'] = $record->value;
        break;
      case 'Qcache_not_cached':
        $ret['Qcache_not_cached'] = $record->value;
        break;

    }
  }
  return $ret;
}

/**
 * This function is a trimmed version of Drupal's system_status function
 *
 * @return array
 */
function acquia_spi_get_system_status() {
  $data = array();

  $profile = drupal_get_profile();
  if ($profile != 'standard') {
    $info = system_get_info('module', $profile);
    $data['install_profile'] = array(
      'title' => 'Install profile',
      'value' => t('%profile_name (%profile-%version)', array(
        '%profile_name' => $info['name'],
        '%profile' => $profile,
        '%version' => $info['version'],
      )),
    );
  }
  $data['php'] = array(
    'title' => 'PHP',
    'value' => phpversion(),
  );
  $conf_dir = TRUE;
  $settings = TRUE;
  $dir = conf_path();
  if (is_writable($dir) || is_writable($dir . '/settings.php')) {
    $value = 'Not protected';
    if (is_writable($dir)) {
      $conf_dir = FALSE;
    }
    elseif (is_writable($dir . '/settings.php')) {
      $settings = FALSE;
    }
  }
  else {
    $value = 'Protected';
  }
  $data['settings.php'] = array(
    'title' => 'Configuration file',
    'value' => $value,
    'conf_dir' => $conf_dir,
    'settings' => $settings,
  );
  $cron_last = variable_get('cron_last', NULL);
  if (!is_numeric($cron_last)) {
    $cron_last = variable_get('install_time', 0);
  }
  $data['cron'] = array(
    'title' => 'Cron maintenance tasks',
    'value' => t('Last run !time ago', array('!time' => format_interval(REQUEST_TIME - $cron_last))),
    'cron_last' => $cron_last,
  );
  if (!empty($GLOBALS['update_free_access'])) {
    $data['update access'] = array(
      'value' => 'Not protected',
      'protected' => FALSE,
    );
  }
  else {
    $data['update access'] = array(
      'value' => 'Protected',
      'protected' => TRUE,
    );
  }
  $data['update access']['title'] = 'Access to update.php';
  if (!module_exists('update')) {
    $data['update status'] = array(
      'value' => 'Not enabled',
    );
  }
  else {
    $data['update status'] = array(
      'value' => 'Enabled',
    );
  }
  $data['update status']['title'] = 'Update notifications';
  return $data;
}

/**
 * Gather information about modules on the site.
 *
 * @return
 *   An associative array keyed by filename of associative arrays with
 *   information on the modules.
 */
function acquia_spi_get_modules() {
  
  // Only do a full rebuild of the module cache every 1 at the most
  $last_build = variable_get('acquia_spi_module_rebuild', 0);
  if ($last_build < REQUEST_TIME - 86400) {
    $modules = system_rebuild_module_data();
    variable_set('acquia_spi_module_rebuild', REQUEST_TIME);
  }
  else {
    $result = db_query("SELECT filename, name, type, status, schema_version, info FROM {system} WHERE type = 'module'");
    foreach ($result as $file) {
      $file->info = unserialize($file->info);
      $modules[$file->filename] = $file;
    }
  }
  
  $result = array();
  $keys_to_send = array('name', 'version', 'package', 'core', 'project');
  foreach ($modules as $filename => $file) {
    $info = array();
    $info['status'] = $file->status;
    foreach ($keys_to_send as $key) {
      $info[$key] = isset($file->info[$key]) ? $file->info[$key] : '';
    }
    $info['filename'] = $file->filename;

    // Determine which files belong to this module and hash them
    $module_path = explode('/', $file->filename);
    array_pop($module_path);

    // We really only care about this module if it is in 'sites' folder.
    // Otherwise it is covered by the hash of the distro's modules
    if ($module_path[0]=='sites') {
      $contrib_path = implode('/', $module_path);
      
      // Get a hash for this module's files. If we nest into another module, we'll return
      // and that other module will be covered by it's entry in the system table.
      //
      // !! At present we aren't going to do a per module hash, but rather a per-project hash. The reason being that it is
      // too hard to tell an individual module appart from a project
      //$info['module_data'] = _acquia_nspi_generate_hashes($contrib_path,array(),array(),TRUE,$contrib_path);
      list($info['module_data']['hashes'], $info['module_data']['fileinfo']) = _acquia_spi_generate_hashes($contrib_path);
    }
    else {
      $info['module_data']['hashes'] = array();
      $info['module_data']['fileinfo'] = array();
    }

    $result[] = $info;
  }
  
  return $result;
}

/**
 * Gather information about nodes, users and comments.
 *
 * @return
 *   An associative array.
 */
function acquia_spi_get_quantum() {
  $quantum = array();
  // Get only published nodes.
  $quantum['nodes'] = db_select('node', 'n')->fields('n', array('nid'))->condition('n.status', NODE_PUBLISHED)->countQuery()->execute()->fetchField();
  // Get only active users.
  $quantum['users'] = db_select('users', 'u')->fields('u', array('uid'))->condition('u.status', 1)->countQuery()->execute()->fetchField();
  if (module_exists('comment')) {
    // Get only active comments.
    $quantum['comments'] = db_select('comment', 'c')->fields('c', array('cid'))->condition('c.status', COMMENT_PUBLISHED)->countQuery()->execute()->fetchField();
  }

  return $quantum;
}

/**
 * Check the presence of UID 0 in the users table.
 *
 * @return bool Whether UID 0 is present.
 *
 */
function acquia_spi_uid_0_present() {
  $count = db_query("SELECT uid FROM {users} WHERE uid = 0")->rowCount();
  return $count == 1 ? TRUE : FALSE;
}

/**
 * Gather hashes of all important files, ignoring line ending and CVS Ids
 *
 * @param $excuded_dirs
 *   Optional array of directory paths to be excluded.
 * 
 * @return
 *   An associative array keyed by filename of hashes.
 */
function acquia_spi_file_hashes($exclude_dirs = array()) {
  // The list of directories for the third parameter are the only ones that
  // will be recursed into.  Thus, we avoid sending hashes for any others.
  list($hashes, $fileinfo) = _acquia_spi_generate_hashes('.', $exclude_dirs, array('modules', 'profiles', 'themes', 'includes', 'misc', 'scripts'));
  ksort($hashes);
  // Add .htaccess file.
  $htaccess = DRUPAL_ROOT . DIRECTORY_SEPARATOR . '.htaccess';
  if (is_file($htaccess)) {
    $owner = fileowner($htaccess);
    if (function_exists('posix_getpwuid')) {
      $userinfo = posix_getpwuid($owner);
      $owner = $userinfo['name'];
    }
    $fileinfo['.htaccess'] = 'mt:' . filemtime($htaccess) . '$p:' . substr(sprintf('%o', fileperms($htaccess)), -4) . '$o:' . $owner . '$s:' . filesize($htaccess);
  }
  return array($hashes, $fileinfo);
}

/**
 * Recursive helper function for acquia_spi_file_hashes().
 */
function _acquia_spi_generate_hashes($dir, $exclude_dirs = array(), $limit_dirs = array(), $module_break = FALSE, $orig_dir=NULL) {
  $hashes = array();
  $fileinfo = array();

  // Ensure that we have not nested into another module's dir
  if ($dir != $orig_dir && $module_break) {
    if (is_dir($dir) && $handle = opendir($dir)) {
      while ($file = readdir($handle)) {
        if (stristr($file, '.module')) {
          return;
        }
      }
    }
  }
  if (isset($handle)) {
    closedir($handle);
  }

  // Standard nesting function
  if (is_dir($dir) && $handle = opendir($dir)) {
    while ($file = readdir($handle)) {
      if (!in_array($file, array('.', '..', 'CVS', '.svn'))) {
        $path = $dir == '.' ? $file : "{$dir}/{$file}";
        if (is_dir($path) && !in_array($path, $exclude_dirs) && (empty($limit_dirs) || in_array($path, $limit_dirs)) && ($file != 'translations')) {
          list($sub_hashes, $sub_fileinfo) =  _acquia_spi_generate_hashes($path, $exclude_dirs);
          $hashes = array_merge($sub_hashes, $hashes);
          $fileinfo = array_merge($sub_fileinfo, $fileinfo);
          $hashes[$path] = acquia_spi_hash_path($path);
        }
        elseif (acquia_spi_is_manifest_type($file)) {
          $hashes[$path] = acquia_spi_hash_path($path);
          $owner = fileowner($path);
          if (function_exists('posix_getpwuid')) {
            $userinfo = posix_getpwuid($owner);
            $owner = $userinfo['name'];
          }
          $fileinfo[$path] = 'mt:' . filemtime($path) . '$p:' . substr(sprintf('%o', fileperms($path)), -4) . '$o:' . $owner . '$s:' . filesize($path);
        }
      }
    }
    closedir($handle);
  }

  return array($hashes, $fileinfo);
}

/**
 * Determine if a path is a file type we care about for modificaitons.
 */
function acquia_spi_is_manifest_type($path) {
  $extensions = array(
    'php' => 1,
    'php4' => 1,
    'php5' => 1,
    'module' => 1,
    'inc' => 1,
    'install' => 1,
    'test' => 1,
    'theme' => 1,
    'engine' => 1,
    'profile' => 1,
    'css' => 1,
    'js' => 1,
    'info' => 1,
    'sh' => 1,
    // SSL certificates
    'pem' => 1,
    'pl' => 1,
    'pm' => 1,
  );
  $pathinfo = pathinfo($path);
  return isset($pathinfo['extension']) && isset($extensions[$pathinfo['extension']]);
}

/**
 * Calculate the sha1 hash for a path.
 *
 * @param $path
 *   The name of the file or a directory.
 * @return
 *   bas64 encoded sha1 hash. 'hash' is an empty string for directories.
 */
function acquia_spi_hash_path($path = '') {
  $hash = '';
  if (file_exists($path)) {
    if (!is_dir($path)) {
      $string = file_get_contents($path);
      // Remove trailing whitespace
      $string = rtrim($string);
      // Replace all line endings and CVS/svn Id tags
      $string = preg_replace('/\$Id[^;<>{}\(\)\$]*\$/', 'x$' . 'Id$', $string);
      $string = preg_replace('/\r\n|\n|\r/', ' ', $string);
      $hash =  base64_encode(pack("H*", sha1($string)));
    }
  }
  return $hash;
}

/**
 * Extract the $_SERVER variable from cache.
 * @return
 *   The global server variable from an earlier pageload.
 */
function acquia_spi_get_server() {
  $cache = cache_get('acquia_spi_server');
  return !empty($cache->data) ? $cache->data : $_SERVER;
}
